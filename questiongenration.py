import os
import re
import time
import pandas as pd
from dotenv import load_dotenv
import google.generativeai as gen_ai
from PyPDF2 import PdfReader
from pymongo import MongoClient
from gtts import gTTS 
import playsound  
import speech_recognition as sr 


# Environment variables
load_dotenv()

GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")
MONGO_URI = os.getenv("MONGO_URI")  

# Gemini-Pro AI model
gen_ai.configure(api_key=GOOGLE_API_KEY)
model = gen_ai.GenerativeModel('gemini-pro')

resume_texts = []
skills = []
questions = []

# MongoDB 
client = MongoClient(MONGO_URI)

# Extract text from resume
def extract_text_from_pdf(file_path):
    try:
        with open(file_path, "rb") as file:
            pdf_reader = PdfReader(file)
            text = ""
            for page in pdf_reader.pages:
                page_text = page.extract_text() or ""  
                text += page_text
            print("Text successfully extracted from the PDF.")
            return text
    except Exception as e:
        print(f"Error extracting text from PDF: {e}")
        return ""

# Extract skills from resume text
def extract_skills(text):
    try:
        # Simple skill extraction based on patterns or keywords
        skill_patterns = [
    r'\bPython\b', r'\bJava\b', r'\bJavaScript\b', r'\bSQL\b', r'\bMachine Learning\b',
    r'\bData Science\b', r'\bDjango\b', r'\bReact\b', r'\bNode.js\b', r'\bHTML\b', r'\bCSS\b',
    r'\bC++\b', r'\bC#\b', r'\bRuby\b', r'\bKotlin\b', r'\bTypeScript\b',r'\bAngular\b',r'\bFlask\b', 
    r'\bSpring Boot\b', r'\bAWS\b', r'\bAzure\b', r'\bGoogle Cloud\b', r'\bDocker\b', r'\bKubernetes\b', 
    r'\bGit\b', r'\bJenkins\b', r'\bLinux\b', r'\bREST API\b',r'\bGraphQL\b', r'\bjQuery\b',r'\bNext.js\b', 
    r'\bExpress.js\b', r'\bMongoDB\b', r'\bSQL\b', r'\bGraphQL\b', r'\bFlutter\b', r'\bReact Native\b',
    r'\bHadoop\b',r'\bJIRA\b',r'\bSalesforce\b', r'\bRESTful API\b',r'\bPower BI\b',r'\bBash\b', r'\bShell Scripting\b',r'\bHadoop\b', r'\bBig Data\b', r'\bData Analytics\b', r'\bData Visualization\b', r'\bR\b',
    r'\bMATLAB\b', r'\bScikit-learn\b', r'\bNLTK\b', r'\bOpenCV\b', r'\bApache\b',r'\bExpress\b', r'\bFastAPI\b',
]

        skills_found = set()
        for pattern in skill_patterns:
            if re.search(pattern, text, re.IGNORECASE):
                skills_found.add(pattern.replace(r'\b', ''))
        
        print(f"Skills extracted: {skills_found}")
        return list(skills_found)
    except Exception as e:
        print(f"Error extracting skills: {e}")
        return []

# Update resume texts and skills
def update_resume(file_path, person_id):
    global resume_texts, skills
    print("Extracting text from the resume...")
    resume_text = extract_text_from_pdf(file_path)
    resume_texts = [resume_text]
    
    if resume_text.strip() == "":
        print("No text found in the resume.")
        return

    print("Extracting skills from the resume text...")
    skills = extract_skills(resume_text)
    # Creating folder for the particular person inside the database
    db = client['resume_analysis']  
    collection = db[person_id]
    return collection

# Function to generate questions with retry and exponential backoff
def generate_questions_with_backoff(prompt, max_retries=5):
    retries = 0
    backoff_time = 2  
    while retries < max_retries:
        try:
            response = model.start_chat().send_message(prompt)
            return response.text.strip()
        except Exception as e:
            if "429" in str(e):
                print(f"Rate limit hit: {e}. Retrying in {backoff_time} seconds...")
                time.sleep(backoff_time)
                retries += 1
                backoff_time *= 2  
            else:
                print(f"Error generating questions: {e}")
                break
    return ""

# Function to generate an analysis prompt for evaluating answers
def generate_analysis_prompt(question, answer):
    return (
        f"Evaluate the following answer to determine if it is relevant to the question provided."
        f"Question: {question}\n"
        f"Answer: {answer}\n"
        f"Is the answer relevant to the question? Respond with 'Yes' if it is relevant, otherwise respond with 'No'."
    )

# Function to analyze the answer and store the result
def analyze_answer(question, user_answer, skill, collection):
    # Generate the model's answer with an example
    prompt = (
        f"Your a expert answer generator. Generate a direct answer for the following question: {question}. "
        f"Also include an eaxmple for each answer the answer generated by you should be understandable to the user."
        f"The answer generated should be medium and understandable I dont need big answers."
    )
    try:
        model_answer = model.start_chat().send_message(prompt).text.strip()
        print(f"Netica Generated Answer: {model_answer}")

        # Generate feedback on user's answer
        analysis_prompt = generate_analysis_prompt(question, user_answer)
        response = model.start_chat().send_message(analysis_prompt)
        feedback = response.text.strip().lower()
        print(f"Model response: {feedback}")

        
        is_relevant = feedback == 'yes'
        store_to_mongodb(question, user_answer, model_answer, skill, is_relevant, collection)
        return is_relevant, model_answer
    except Exception as e:
        print(f"Error analyzing answer: {e}")
        return False, ""

# Function to store data into MongoDB
def store_to_mongodb(question, user_answer, model_answer, skill, is_relevant, collection, hr_question=False):
    try:
        # Check if a document for the skill already exists
        existing_document = collection.find_one({'skill': skill})

        if existing_document:
            # Update existing document
            collection.update_one(
                {'skill': 'HR'} if hr_question else {'skill': skill},
                {
                    '$push': {
                        'questions': {
                            'question': question,
                            'user_answer': user_answer,
                            'model_answer': model_answer,
                            'relevant': is_relevant
                        }
                    }
                }
            )
        else:
            document = {
                'skill': 'HR' if hr_question else skill,
                'questions': [
                    {
                        'question': question,
                        'user_answer': user_answer,
                        'model_answer': model_answer,
                        'relevant': is_relevant
                    }
                ]
            }
            collection.insert_one(document)

        print(f"Stored question, user answer, model answer, and relevance for skill '{skill}' into MongoDB collection '{collection.name}'.")
    except Exception as e:
        print(f"Error storing data into MongoDB: {e}")

# Function to categorize questions into easy, normal, and hard levels
def categorize_questions(questions):
   
    easy, normal, hard = [], [], []
    if len(questions) >= 3:
        easy = [questions[0]] 
        normal = [questions[1]] if len(questions) > 1 else []  
        hard = [questions[2]] if len(questions) > 2 else []  
    else:
        easy = questions[:1]
        normal = questions[1:2]
        hard = questions[2:3]
    return easy, normal, hard

# Function to generate questions based on skills 
def generate_questions_based_on_skills(skill):
    if not skills:
        return "No skills found in the resume."

    prompt = (
        f"Generate a list of specific interview questions directly related to the skill '{skill}'. "
        f"Only list clear, direct questions without any extra text."
    )

    gemini_response_text = generate_questions_with_backoff(prompt)

    if not gemini_response_text:
        return [], [], []
    
    
    questions = [q.strip() for q in gemini_response_text.split('\n') if q.strip()]
    questions = [re.sub(r'^[\*\d+\.]+[\s\-]*', '', q).strip() for q in questions]

    questions = [q for q in questions if q and q[-1] == '?']
    
    easy, normal, hard = categorize_questions(questions)
    return easy, normal, hard

# Function to generate HR-related questions
def generate_hr_questions():
    prompt = (
        "Generate a list of common HR interview questions. These questions should cover topics like teamwork, "
        "conflict resolution, career goals, work ethic and question why you want to join netanalytiks? this should be mandatory question. Only list clear, direct questions without any extra text in the prefix like number."
        "Generate only three questions . Not more then three questions."
    )

    gemini_response_text = generate_questions_with_backoff(prompt)

    if not gemini_response_text:
        return []
    
    hr_questions = [q.strip() for q in gemini_response_text.split('\n') if q.strip()]
    hr_questions = [re.sub(r'^[\*\d+\.]+[\s\-]*', '', q).strip() for q in hr_questions]

    hr_questions = [q for q in hr_questions if q and q[-1] == '?']
    
    return hr_questions[:3]


# Function to validate if the response is a direct question
def is_valid_question(question):
    unwanted_patterns = ['Interview Questions', 'Technical Skills', 'Summary:', '**']
    for pattern in unwanted_patterns:
        if pattern.lower() in question.lower():
            return False
    return True

# Function to generate an overall score based on the relevance of answers
def generate_overall_score(collection):
    try:
        # Retrieve data from MongoDB
        data = list(collection.find({}, {'_id': 0, 'questions.relevant': 1}))
        df = pd.DataFrame(data)

        if df.empty:
            print("No data available to generate a score.")
            return

        # Count relevant and non-relevant answers
        relevant_answers = 0
        total_answers = 0

        for doc in data:
            if 'questions' in doc:
                for question in doc['questions']:
                    if 'relevant' in question:
                        total_answers += 1
                        if question['relevant']:
                            relevant_answers += 1

        if total_answers == 0:
            print("No answers available to calculate score.")
            return

        relevance_ratio = relevant_answers / total_answers
        score = max(0, min(10, round(relevance_ratio * 10)))  # Scale score from 0 to 10

        print(f"\nOverall Score: {score}/10")

    except Exception as e:
        print(f"Error generating overall score: {e}")

# Function to generate speech from text
def speak(text):
    try:
        tts = gTTS(text=text, lang='en')
        audio_file = "question.mp3"
        tts.save(audio_file)
        playsound.playsound(audio_file)
        os.remove(audio_file)  
    except Exception as e:
        print(f"Error during TTS: {e}")

# Function to capture spoken answer using speech recognition
def capture_spoken_answer():
    recognizer = sr.Recognizer()
    mic = sr.Microphone()
    with mic as source:
        print("Listening... Please speak your answer now.")
        recognizer.adjust_for_ambient_noise(source)
        audio = recognizer.listen(source)
    try:
        answer = recognizer.recognize_google(audio)
        print(f"You said: {answer}")
        return answer
    except sr.UnknownValueError:
        print("Sorry, I could not understand your speech. Please try again.")
    except sr.RequestError as e:
        print(f"Could not request results from Google Speech Recognition service; {e}")
    return ""

# Function to capture user answer through text or speech
def get_user_answer():
    print("\nChoose input method:")
    print("1. Type your answer")
    print("2. Speak your answer")

    method = input("Enter 1 or 2: ").strip()
    if method == '1':
        return input("Your Answer: ")
    elif method == '2':
        return capture_spoken_answer()
    else:
        print("Invalid option. Defaulting to text input.")
        return input("Your Answer: ")
                
def speak_introduction(user_name, skills):
    skills_list = ', '.join(skills)
    intro_text = (
        f"Hi {user_name}, my name is Netica, and I will be your instructor for today's test.."
        f"By going through your resume, you seem well-versed in skills like {skills_list}. "
        f"So let's get started with your test."
    )
    print(intro_text)  
    speak(intro_text)
    
# Main function 
def main():
    person_id = input("Enter your Name : ")
    if not person_id:
        print("Invalid identifier. Please provide a unique identifier for the person.")
        return
    
    
    user_name = person_id.split()[0] 
    

    file_path = input("Provide Your resume (PDF) here: ")
    if not os.path.isfile(file_path):
        print("Invalid file path. Please provide a valid path to the resume.")
        return

    collection = update_resume(file_path, person_id)
    if collection is None:
        return
    
    
    
    if skills:
        speak_introduction(user_name, skills)
    else:
        print("No skills found in the resume, skipping the introduction.")
        return

    for skill in skills:
        easy, normal, hard = generate_questions_based_on_skills(skill)

        questions_dict = {
            "Easy": easy,
            "Normal": normal,
            "Hard": hard
        }

        print(f"\nGenerating questions for the skill: {skill}")
        
        for level, questions in questions_dict.items():
            for question in questions:
                if is_valid_question(question):
                    print(f"\nLevel: {level} | Question: {question}")
                    speak(question)  

                    user_answer = get_user_answer()
                    if not user_answer.strip():
                        print("No answer provided, skipping to the next question.")
                        continue
                    
                    is_relevant, model_answer = analyze_answer(question, user_answer, skill, collection)

                    if not is_relevant:
                        if level == "Easy":
                            print(f"Skipping to the next question for skill '{skill}' due to irrelevant answer.")
                            break
                        elif level == "Normal":
                            print("Skipping to the next skill question due to mistake in normal level.")
                            break
                        
                        
    hr_intro_message = "Oki , Now let's move on to the HR-based questions."
    print(hr_intro_message)
    speak(hr_intro_message)
    
        # Adding HR-based questions
    print("\nGenerating HR-based questions...")
    hr_questions = generate_hr_questions()
    if hr_questions:
        for question in hr_questions:
            print(f"\nHR Question: {question}")
            speak(question)  

            user_answer = get_user_answer()
            if not user_answer.strip():
                print("No answer provided, skipping to the next HR question.")
                continue

    generate_overall_score(collection)
    
    thank_you_message = "Thank You, for taking the test. Have a great day!"
    print(thank_you_message)
    speak(thank_you_message)

if __name__ == "__main__":
    main()
